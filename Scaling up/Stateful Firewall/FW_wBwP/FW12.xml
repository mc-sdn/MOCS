<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>/* This is about checking the single FW. 
 * Contrary to Kuai, the active flows (controller's global View) now
 * will be updated after the rules are installed in the ft, when the controller
 * gets notified about it (with barrier_reply: we add a new queue in the controller called bRb
 *
 * The barrier_reply is modelled in the gV process: the barrier_repply is the add_rule_to_gv_32(r, sw)
 * which is enabled when bRb is not empty
 *
 * The Rules are modelled having each barrier_ids for each switch: each barrier_id shadows a set of preceding rules. 
 * The barrier id is set by the controller when the rule is sent, and once it is added to the cb,
 * all the preceding rules in cb which are orphan of barriers are assigned this barrier id.
 * Rules, also are marked with a bool cb per switch.
 *
 * To keep track of whhich barrier comes first, we use the int barriers_out[SW][bar] to store the barriers
 * in the sequence they were deployed: so in [bar] we store the barriers in the order they were deployed.

    The property:   if a pkt is dropped by a rule in a switch (not by pOut message), 
                    this implies that it is not in the gV
 */

/*  cd /Volumes/LocalDataHD/v/vk/vk207/Box/uppaal/Kuai\ experiments/SSH\ bitvector 
 *  /Volumes/LocalDataHD/v/vk/vk207/Box/uppaal/sdn/verifyta -d -S2 -u  FW_1x2__.xml por.q
 */


/* Manual bitfield manipulation - UPPAAL has not bitfield construct of its own
 */

//const int Bound = 1;
//const int multiplicity =  1;
const int switches     =  1;
const int clients      =  5;
const int ports        =  5;  /* the max number of ports a switch in the topology in question might have */


const int rules_no     =  20; 
const int configure_rules_no   =  4;
const int packets_no   =  4;  /* The number of packets here (4) is the number of slots: 
                               * each slot can hold switches^3 (because we have 3 packet buffers per switch)   
                                 So, a 32-bit integer holds 8 packets for a 2-switches topology
                               */
const int barriers_no = 1;


/*   The default integer range in UPPAAL is small (±2^16). 
 *   However, integer ranges up to 32 bits are supported, so we define custom ranges 
 */

typedef int [-(1 &lt;&lt;31),(1&lt;&lt;31)-1] int32_t ; // a signed 32 bit integer data type (−2,147,483,648 to 2,147,483,647)
typedef int [0,(1&lt;&lt;32)-1] uint32_t ; // an unsigned 32 bit integer data type (0 to 4,294,967,295)

/*
 *  Defining bit flags : a symbolic constant to give a meaningful name to each bit used 
 *                       (left-shift operator to shift a bit into the proper location).
 */
//const	int32_t	bit0	=	1	&lt;&lt;	0	;  // 0000 0000 0000 0000 0000 0000 0000 0001 (2^0)
//const	int32_t	bit1	=	1	&lt;&lt;	1	;  // 0000 0000 0000 0000 0000 0000 0000 0010 (2
//const	int32_t	bit2	=	1	&lt;&lt;	2	;  // 0000 0000 0000 0000 0000 0000 0000 0100
//const	int32_t	bit3	=	1	&lt;&lt;	3	;  // 0000 0000 0000 0000 0000 0000 0000 1000
//const	int32_t	bit4	=	1	&lt;&lt;	4	;  // 0000 0000 0000 0000 0000 0000 0001 0000
//const	int32_t	bit5	=	1	&lt;&lt;	5	;  // 0000 0000 0000 0000 0000 0000 0010 0000
//const	int32_t	bit6	=	1	&lt;&lt;	6	;  // 0000 0000 0000 0000 0000 0000 0100 0000
//const	int32_t	bit7	=	1	&lt;&lt;	7	;  // 0000 0000 0000 0000 0000 0000 1000 0000
//const	int32_t	bit8	=	1	&lt;&lt;	8	;
//const	int32_t	bit9	=	1	&lt;&lt;	9	;
//const	int32_t	bit10	=	1	&lt;&lt;	10	;
//const	int32_t	bit11	=	1	&lt;&lt;	11	;
//const	int32_t	bit12	=	1	&lt;&lt;	12	;
//const	int32_t	bit13	=	1	&lt;&lt;	13	;
//const	int32_t	bit14	=	1	&lt;&lt;	14	;
//const	int32_t	bit15	=	1	&lt;&lt;	15	;
//const	int32_t	bit16	=	1	&lt;&lt;	16	;
//const	int32_t	bit17	=	1	&lt;&lt;	17	;
//const	int32_t	bit18	=	1	&lt;&lt;	18	;
//const	int32_t	bit19	=	1	&lt;&lt;	19	;
//const	int32_t	bit20	=	1	&lt;&lt;	20	;
//const	int32_t	bit21	=	1	&lt;&lt;	21	;
//const	int32_t	bit22	=	1	&lt;&lt;	22	;
//const	int32_t	bit23	=	1	&lt;&lt;	23	;
//const	int32_t	bit24	=	1	&lt;&lt;	24	;
//const	int32_t	bit25	=	1	&lt;&lt;	25	;
//const	int32_t	bit26	=	1	&lt;&lt;	26	;
//const	int32_t	bit27	=	1	&lt;&lt;	27	;
//const	int32_t	bit28	=	1	&lt;&lt;	28	;
//const	int32_t	bit29	=	1	&lt;&lt;	29	;
//const	int32_t	bit30	=	1	&lt;&lt;	30	;
//const	int32_t	bit31	=	1	&lt;&lt;	31	;



// to turn bit 4 ON  of variable v we use bitwise OR:   v |= bit4;    or    v |= 1 &lt;&lt; 4;
// to turn bit 4 OFF of variable v we use bitwise AND with an inverse bit pattern:   v = v &amp;(bit4 ^ -1);
// to toggle a bit state we use bitwise XOR:
//                                            v ^= bit4;          --flip bit4 from on to off, or vice versa
//                                            v ^= (bit4 | bit5); --flip bit4 and 5 at the same time  
// to toggle all bits:    v ^= -1             
// Determining if a bit is on or off:  
//                                    if (v &amp; bit4) then "v has bit4 set"
//                                    if (!(v &amp; bit4)) then "v does not have bit4 set"


//clock now; /* In order to record the total amount of time that has elapsed, we introduce a global clock now , which is never reset. */


/* Function to get no of bits in binary 
   representation of positive integer */
int countBits(int[0,(1&lt;&lt;15)-1] n){
  int bits = 0; 
   while (n) 
   { 
        bits++; 
        n &gt;&gt;= 1; 
    } 
    return bits; 
}


/* 
 * Packet Match fields
 */
const int _src_           = 11; 
const int _dest_          = 12; 
const int _in_port_       = 13; 
const int _out_port_      = 14; 
const int _src_port_      = 15; 
const int _dest_port_     = 16; 
const int _prio_          = 17; 
const int _install_       = 18; 
const int _barrier_       = 19; /* if a rule has barrier set it means that this one or previous rules must be installed first */
/* 
 * Location
 */
const int _pb_            = 20;
const int _pIb_           = 21;
const int _pOb_           = 22;
const int _cb_            = 23;
const int _ft_            = 24;
//const int _gv_            = 25;





int bitfield_length(int field){

  int bits;

        if(field == _src_)         {bits = 3;}
  else  if(field == _dest_)        {bits = 3;}
  else  if(field == _in_port_)     {bits = 3;}
  else  if(field == _out_port_)    {bits = 3;}
  else  if(field == _src_port_)    {bits = 2;}
  else  if(field == _dest_port_)   {bits = 2;}
  else  if(field == _prio_)        {bits = 2;}
  else  if(field == _install_)     {bits = 1;}
  else  if(field == _barrier_)     {bits = 1;}
  else  if(field == _pb_)          {bits = switches;}
  else  if(field == _pIb_)         {bits = switches;}
  else  if(field == _pOb_)         {bits = switches;}
  else  if(field == _cb_)          {bits = switches;}
  else  if(field == _ft_)          {bits = switches;}
//  else  if(field == _gv_)          {bits = switches;}

    return bits;
}



int from_bit(int field)
{
  int from ;

         if(field == _src_)        {from =  0;}
   else  if(field == _dest_)       {from =  3;}
   else  if(field == _in_port_)    {from =  6;}
   else  if(field == _out_port_)   {from =  9;}
   else  if(field == _src_port_)   {from = 12;}
   else  if(field == _dest_port_)  {from = 14;}
   else  if(field == _pb_)         {from = 16;}
   else  if(field == _pIb_)        {from = 17;}
   else  if(field == _pOb_)        {from = 18;}
   else  if(field == _prio_)       {from = 16;}
   else  if(field == _install_)    {from = 18;}
   else  if(field == _barrier_)    {from = 19;}
   else  if(field == _cb_)         {from = 20;}
   else  if(field == _ft_)         {from = 21;}
//   else  if(field == _gv_)         {from = 22;}

    return from;
}



const int32_t mask_src       = ((1 &lt;&lt; bitfield_length(_src_)) -1 )       &lt;&lt; from_bit(_src_);
const int32_t mask_dest      = ((1 &lt;&lt; bitfield_length(_dest_)) -1 )      &lt;&lt; from_bit(_dest_);
const int32_t mask_in_port   = ((1 &lt;&lt; bitfield_length(_in_port_)) -1 )   &lt;&lt; from_bit(_in_port_);
const int32_t mask_out_port  = ((1 &lt;&lt; bitfield_length(_out_port_)) -1 )  &lt;&lt; from_bit(_out_port_);
const int32_t mask_src_port  = ((1 &lt;&lt; bitfield_length(_src_port_)) -1 )  &lt;&lt; from_bit(_src_port_);
const int32_t mask_dest_port = ((1 &lt;&lt; bitfield_length(_dest_port_)) -1 ) &lt;&lt; from_bit(_dest_port_);
const int32_t mask_prio      = ((1 &lt;&lt; bitfield_length(_prio_)) -1 )      &lt;&lt; from_bit(_prio_);
const int32_t mask_install   = ((1 &lt;&lt; bitfield_length(_install_)) -1 )   &lt;&lt; from_bit(_install_);
const int32_t mask_pb        = ((1 &lt;&lt; bitfield_length(_pb_)) -1 )        &lt;&lt; from_bit(_pb_);
const int32_t mask_pIb       = ((1 &lt;&lt; bitfield_length(_pIb_)) -1 )       &lt;&lt; from_bit(_pIb_);
const int32_t mask_pOb       = ((1 &lt;&lt; bitfield_length(_pOb_)) -1 )       &lt;&lt; from_bit(_pOb_);
const int32_t mask_cb        = ((1 &lt;&lt; bitfield_length(_cb_)) -1 )        &lt;&lt; from_bit(_cb_);
const int32_t mask_ft        = ((1 &lt;&lt; bitfield_length(_ft_)) -1 )        &lt;&lt; from_bit(_ft_);
//const int32_t mask_gv        = ((1 &lt;&lt; bitfield_length(_gv_)) -1 )        &lt;&lt; from_bit(_gv_);

const int32_t mask_same_pkt = mask_src | mask_dest  |  mask_in_port |  mask_src_port |  mask_dest_port ; //  for 6x3  16191;          //b11111100111111
const int32_t mask_same_pkt_alpha = mask_src | mask_dest |  mask_in_port ;
const int32_t mask_same_rule = mask_src | mask_dest  |  mask_out_port |  mask_src_port |  mask_dest_port| mask_prio | mask_install;   



//const int32_t mask_src = 3;          // b00000000000000000000000000000011  - 2^from + 2^to
//const int32_t mask_dest = 12;        // b00000000000000000000000000001100
//const int32_t mask_in_port = 48;     // b00000000000000000000000000110000
//const int32_t mask_out_port = -64;   // b00000000000000000000000011000000
//const int32_t mask_reached = 16128;  // b00000000000000000011111100000000
//const int32_t mask_prio = 256;       // b00000000000000000000000100000000
//const int32_t mask_install = 512;    // b00000000000000000000001000000000
//const int32_t mask_pb = 1032192;     // b00000000000011111100000000000000
//const int32_t mask_pIb = 66060288;   // b00000011111100000000000000000000
//const int32_t mask_pOb = -67108864;  // b11111100000000000000000000000000
//const int32_t mask_cb = -1024;       // b00000000000000001111110000000000
//const int32_t mask_ft = 4128768;     // b00000000001111110000000000000000




const int32_t init_rule = (1 &lt;&lt; from_bit(_prio_)) | (1 &lt;&lt; from_bit(_install_));



/* 
 *
 *****************************************************************************************************************
 *
 *    SWITCHES
 *
 *****************************************************************************************************************
 * 
 */
const bool oo_pq = 1; // this is the infinite abstraction
const bool oo_pIOq = 0; // this is the infinite abstraction
const bool oo_cq = 0; // this is the infinite abstraction
const bool fwd_optimisation = 1;
const bool ctrl_optimisation = 1;
const bool reply_optimisation = 0;
const bool stateful_controller = 0;

const bool all_pkts_1_shot = 0;

//const bool optimisation_on = 0;




typedef int[1,rules_no] rul;
typedef int[1,configure_rules_no] configure_rul;
typedef int[1,packets_no] pkts;

typedef int[1,switches] SW1; /* Set of all switches (bounded integer) */
typedef int[1,clients] C1;   /* Set of all clients */

typedef int[5000,4999+switches] SW; /* Set of all switches (bounded integer) - shifted */
typedef int[6000,5999+clients] C;   /* Set of all clients -shifted */
typedef int[4999,5999+clients] mis_SW_C; /* All nodes: clients, switches and the misconn */
typedef int[0,10] priority_t;
typedef int[0,ports] port_t;
typedef int[1,2] ip_port_t;
typedef int[1,ports] phys_ports;
typedef int[1,barriers_no] bar;
typedef int[0,barriers_no*switches -1] BarTimesSw;



bool barriers_out[SW][bar]; // this table stores the position of a barriers


const int wildcard      = 0;  
const int discard       =  0;  /* 0 encodes the drop action */
const int recipient_missing = -1; /* recipient_missing from MAC table */
const int misconnection       = 4999;
const int client_port   =   1;
const int first_switch   = 5000;
const int last_switch   = 4999 + switches;
const int mid_switch    = 5000 + switches/2;
const int first_client   = 6000;
const int last_client   = 5999 + clients;

//const int32_t invariant_changed = 1 &lt;&lt; 31;

typedef struct
{
  int xid;
  int sw;
} barrier ;


bool bRb[SW][bar];






/*  The configuration file is a list of tuples of the form
 *  (client1, port1, client2, port2)
 */
bool flows[C1][ip_port_t][C1][ip_port_t][SW1];  



//==========================================
bool invariant_failed;
//==========================================



int32_t P[pkts]; 
int32_t R[rul]; 




void set_bit(int32_t &amp;n, int pos){

    n |= 1 &lt;&lt; pos;
}


void clear_bit(int32_t &amp;n, int pos){

    n &amp;= ((1 &lt;&lt; pos) ^ -1);  
}



void unset_bitfield(int field_id, int32_t &amp;p_r){
  int from = from_bit(field_id);
  int to   = from + bitfield_length(field_id) - 1;
  int i;
        for (i = from; i &lt;= to; i++ ){
            clear_bit(p_r, i);
		}
}


/* A bitfield is a range of bits working as a single number. 
 * We (usually) can't access these ranges directly because 
 * memory is accessed in (multi-)byte-sized datatypes
 * Bits 0-1, for e.g., are acting as 'src', 2 and 3 as the 'dest' field and 4-6 as the 'reached', etc.
 *
 * For e.g., assuming that up to 3 ports are present in the topology, two bits are enough (mask = 3) to store them. 
 * So, the in_port pt will be encoded in packet pk (positions 10 and 11) as follows:

pt: **************nn  // 
pt: 00000000000000nn  // pt &amp; 3
pt: 0000nn0000000000  // pt = (pt &amp; 3) &lt;&lt; 10

pk: bbbbPPtttttttttt  // 
pk: bbbb00tttttttttt  // pk = (pk &amp; ((3 &lt;&lt; 10) ^ -1) )
pk: bbbbnntttttttttt  // pk = pk | pt


 */
void encode_bitfield(int field_id, int32_t dec_new_field_val, int32_t &amp;p_r){

  int from = from_bit(field_id);
  int mask = (1 &lt;&lt; bitfield_length(field_id)) -1 ;  // for "masking off" (masking to 0) 

    if(bitfield_length(field_id) == 1){

        set_bit(p_r, from_bit(field_id) );

    }
    else{
        dec_new_field_val = (dec_new_field_val &amp; mask) &lt;&lt; from_bit(field_id);
        p_r = (p_r &amp; (   (mask &lt;&lt; from_bit(field_id)) ^ -1 )         );
        p_r = p_r | dec_new_field_val;
    } 

}


void encode_barrier_for_specific_switch(int32_t b_id, int32_t &amp;p_r, SW sw){

  int from = from_bit(_barrier_)  + ( (sw-first_switch) * (bitfield_length(_barrier_)/switches)    );
  int mask = (1 &lt;&lt; (bitfield_length(_barrier_)/switches)) -1 ;  // for "masking off" (masking to 0) 

    if(bitfield_length(_barrier_) == 1){

        set_bit(p_r, from_bit(_barrier_) );

    }
    else{
        b_id = (b_id &amp; mask) &lt;&lt; from;
        p_r = (p_r &amp; (   (mask &lt;&lt; from) ^ -1 )         );
        p_r = p_r | b_id;
    } 

}


int decode_barrier_for_specific_switch(int32_t p_r, SW sw){

  int32_t i = p_r;
  int from = from_bit(_barrier_)  + ( (sw-first_switch) * (bitfield_length(_barrier_)/switches)    );
  int mask = (1 &lt;&lt; (bitfield_length(_barrier_)/switches)) -1 ;  // for "masking off" (masking to 0) 
  int32_t y;

    if(bitfield_length(_barrier_) == 1){
        if( i &amp; (1 &lt;&lt; from_bit(_barrier_)) ){
            y = 1;
        }
        else{
            y = 0;
        }
    }
    else{
        y = (i &gt;&gt;  from ) &amp; mask;
    }
    return y; 
}


int decode_bitfield(int field_id, int32_t p_r){

  int32_t i = p_r;
  int mask = (1 &lt;&lt; bitfield_length(field_id)) -1 ; // for "masking off" (masking to 0) 
  int32_t y;

    if(bitfield_length(field_id) == 1){
        if( i &amp; (1 &lt;&lt; from_bit(field_id)) ){
            y = 1;
        }
        else{
            y = 0;
        }
    }
    else{
        y = (i &gt;&gt;  from_bit(field_id) ) &amp; mask;
    }
    return y; 
}


void undef_packet_32(int32_t &amp;p){

  //  p |= 1 &lt;&lt; 31 ;  // 1000 0000 0000 0000 0000 0000 0000 0000 (- 2,147,483,648)
     p = 0;
}





void undef_rule_32(int32_t &amp;r){

   // r |= 1 &lt;&lt; 31 ;  // 1000 0000 0000 0000 0000 0000 0000 0000 (- 2,147,483,648)
      r = 0;
}


/*
void init_rule_32(int32_t &amp;r){ // gives default values to fields that should be defined 

    encode_bitfield(out_port, discard, r);
    encode_bitfield(prio, 1, r);
    encode_bitfield(install, true, r);

}
*/



bool can_communicate(C l_client, C r_client)
{
    bool comm;

        if(
            (l_client == 6000 &amp;&amp; r_client == 6003) or
            (l_client == 6003 &amp;&amp; r_client == 6000) 

          )
        {comm = true;}

    return comm;
}

int client_pairs_communicating(){
    int i = 0;
    for(s : C){
        for(d : C){
            if(can_communicate(s, d) ){
                i++;
            }
        }
    }
return i;
}



int out_port_of_packet_32(int32_t p){
    return (decode_bitfield(_out_port_,p));
}

//int packet_MAC(int32_t p){
//    return (decode_bitfield(_src_, p)+first_client -1);
//}







bool oo_32(int32_t p1, int32_t p2){


       return(        
                ((p1 &amp; mask_same_pkt)        ==     (p2 &amp; mask_same_pkt))      
        );
}


int priority_of_rule_32(int32_t r){
    return (decode_bitfield(_prio_,    r));
}

int out_port_of_rule_32(int32_t r){
    return (decode_bitfield(_out_port_,r));
}


/* An undefined field (wildcard, all-x), can be matched by any packet's corresponding field 
 * r1 is the one already installed and r2 the one to be installed
 */
bool same_rules_32(int32_t r1, int32_t r2) 
{

  int32_t r1_src_m =  r1 &amp; mask_src;
  int32_t r2_src_m =  r2 &amp; mask_src;

  int32_t r1_dest_m =  r1 &amp; mask_dest;
  int32_t r2_dest_m =  r2 &amp; mask_dest;

  int32_t r1_src_port_m =  r1 &amp; mask_src_port;
  int32_t r2_src_port_m =  r2 &amp; mask_src_port;

  int32_t r1_dest_port_m =  r1 &amp; mask_dest_port;
  int32_t r2_dest_port_m =  r2 &amp; mask_dest_port;

  int32_t r1_out_port_m =  r1 &amp; mask_out_port;
  int32_t r2_out_port_m =  r2 &amp; mask_out_port;

  int32_t r1_prio_m =  r1 &amp; mask_prio;
  int32_t r2_prio_m =  r2 &amp; mask_prio;

  int32_t r1_install_m =  r1 &amp; mask_install;
  int32_t r2_install_m =  r2 &amp; mask_install;

    return(

    r1 != 0 &amp;&amp; r2 != 0        and

    (  r1_src_m == wildcard imply r2_src_m == wildcard   )  and
    (  r2_src_m == wildcard imply r1_src_m == wildcard   )  and

    (  r1_dest_m == wildcard imply r2_dest_m == wildcard   )  and
    (  r2_dest_m == wildcard imply r1_dest_m == wildcard   )  and

    (  r1_src_port_m == wildcard imply r2_src_port_m == wildcard   )  and
    (  r2_src_port_m == wildcard imply r1_src_port_m == wildcard   )  and

    (  r1_dest_port_m == wildcard imply r2_dest_port_m == wildcard   )  and
    (  r2_dest_port_m == wildcard imply r1_dest_port_m == wildcard   )  and

    (  r1_src_m     != wildcard imply  r1_src_m     == r2_src_m      )  and
    (  r1_dest_m    != wildcard imply  r1_dest_m    == r2_dest_m     )  and
    (  r1_src_port_m != wildcard imply r1_src_port_m == r2_src_port_m  )  and
    (  r1_dest_port_m != wildcard imply r1_dest_port_m == r2_dest_port_m  )  and

                                                      (  r1_out_port_m == r2_out_port_m )  and
                                                      (  r1_prio_m     == r2_prio_m     )  and
                                                      (  r1_install_m  == r2_install_m  )  
   ) ;
}



bool oo_rules_32(int32_t r1, int32_t r2) 
{

    return(

            ((r1 &amp; mask_same_rule)        ==     (r2 &amp; mask_same_rule))    
                                              ) ;
}




/* Two flow entries overlap if a single packet may match both, and  
 * if a field is undefined for one rule and defined for another
 * coz undefined (omitted) fields are wildcards (having value ANY): we say field is wildcarded (not present)
 */
bool overlapping_rules_32(int32_t r1, int32_t r2)
{

  int32_t r1_src_m =  r1 &amp; mask_src;
  int32_t r2_src_m =  r2 &amp; mask_src;

  int32_t r1_dest_m =  r1 &amp; mask_dest;
  int32_t r2_dest_m =  r2 &amp; mask_dest;

  int32_t r1_src_port_m =  r1 &amp; mask_src_port;
  int32_t r2_src_port_m =  r2 &amp; mask_src_port;

  int32_t r1_dest_port_m =  r1 &amp; mask_dest_port;
  int32_t r2_dest_port_m =  r2 &amp; mask_dest_port;


    return(

            (r1 != 0 &amp;&amp; r2 != 0                      and

              ( same_rules_32(r1,r2)   ||

               !( 
                    (  r1_src_m == wildcard imply r2_src_m == wildcard   )  and
                    (  r2_src_m == wildcard imply r1_src_m == wildcard   )  and

                    (  r1_dest_m == wildcard imply r2_dest_m == wildcard   )  and
                    (  r2_dest_m == wildcard imply r1_dest_m == wildcard   )  and

                    (  r1_src_port_m == wildcard imply r2_src_port_m == wildcard   )  and
                    (  r2_src_port_m == wildcard imply r1_src_port_m == wildcard   )  and

                    (  r1_dest_port_m == wildcard imply r2_dest_port_m == wildcard   )  and
                    (  r2_dest_port_m == wildcard imply r1_dest_port_m == wildcard   )  
                ) 
              )                                                           
            )                                               
          );
}





//linear search 
int rule_position_32(int32_t r)
{
   int j; 

   for (j = 1; j &lt;= rules_no; ++j)
   {
      if ( (r&amp;mask_same_rule) == (R[j]&amp;mask_same_rule))
      {
         return j; 
      }
   }
   return -1; //value not found
}


//iterative binary search
int rule_position_(int32_t r){
   int first  = 1;
   int last   = rules_no;
   int middle;
   
    while (first &lt;= last)
    {
        middle = first + (last - first)/2;

        if ((r&amp;mask_same_rule) == (R[middle]&amp;mask_same_rule))
            return middle;

        if ((r&amp;mask_same_rule) &gt; (R[middle]&amp;mask_same_rule))
            first = middle + 1;
        else 
            last = middle - 1;
    }
    return -1; //search value not found
}




bool rule_installed_32(rul r, SW sw){
 
    return (   (R[r] &amp; (1 &lt;&lt; (from_bit(_ft_)+sw-first_switch) )) != 0 );
}
 

bool rule_in_cb_32(rul r, SW sw){ 
 
    return (   (R[r] &amp; (1 &lt;&lt; (from_bit(_cb_)+sw-first_switch) )) != 0 );
}


/*
bool rule_in_gv_32(rul r, SW sw){
 
    return (   (R[r] &amp; (1 &lt;&lt; (from_bit(_gv_)+sw-first_switch) )) != 0 );
}
*/

bool rule_adds_flow_entry_32(rul r, SW sw){
 
    return (   (R[r] &amp; mask_install) != 0  );
}


/*
int no_of_rules_and_b_send(SW sw){
  int j, l;
    for(i : rul){
        if(  rule_in_cb_32(i, sw)  or rule_installed_32(i, sw)   ){
            j++;
        }
    }
    for(k : bar){
        if(  barriers_out[k][sw] != 0   ){
            l++;
        }
    }
return j+l;
}
*/

bool b1_earlier_than_b2(bar b1, bar b2, SW sw){

    return(
            exists(i : bar) exists(j : bar) barriers_out[sw][i] == b1 and barriers_out[sw][j] == b2 and i&lt;j
    );
}

void send_rule_32(rul r, SW sw){
  int j = 1;
  int k;
  int b_id = decode_barrier_for_specific_switch(R[r], sw);

    if( // the rule is added only if it is not already deployed
          !rule_in_cb_32(r, sw) and
       ((  rule_adds_flow_entry_32(r, sw) and !rule_installed_32(r,sw)  )  or  
        ( !rule_adds_flow_entry_32(r, sw) and  rule_installed_32(r,sw)  )
                                                                                )){
            set_bit(  R[r], from_bit(_cb_)+sw-first_switch  );

                if( b_id &gt; 0 ){
                    for(i : rul){ // here we mark all rules which are in sw.cb but barrier is zero (we shadow the preceding rules)
                        if(rule_in_cb_32(i, sw) and decode_barrier_for_specific_switch(R[i], sw) == 0){
                            encode_barrier_for_specific_switch(b_id, R[i], sw);

                        }
                    }
                             barriers_out[sw][b_id] = true; // bookkeeping for the barriers                           

                }
          }
}
 




void enable_barrier_reply(rul r, SW sw){
  int j = 1;
  int current_barrier = decode_barrier_for_specific_switch(R[r], sw);

    if(current_barrier &gt; 0){
        if( !exists(i : rul)     // i.e., there is no rule (other than r) in sw.cb with same barrier_id   
                                     i != r  
                                and  rule_in_cb_32(i, sw)  
                                and  decode_barrier_for_specific_switch(R[i], sw) ==  current_barrier
                                                                                                      )
        {
            bRb[sw][current_barrier] = true;


                            barriers_out[sw][current_barrier] = false; 
        }
    }
}  





void add_rule_to_ft_32(rul r, SW sw){

        set_bit(  R[r], from_bit(_ft_)+sw-first_switch  );
        enable_barrier_reply(r, sw);
}


void remove_rule_from_ft_32(rul r, SW sw){

        clear_bit(R[r], from_bit(_ft_)+sw-first_switch );
        enable_barrier_reply(r, sw);
}





bool node_is_client(int[4999,5999+clients] node){
    return(
            node &gt;= first_client &amp;&amp; node &lt; first_client+clients
          );
}

bool node_is_switch(int[4999,5999+clients] node){
    return(
            node &gt;= first_switch &amp;&amp; node &lt; first_switch+switches
          );
}


/* The below topology is set up in such a way that the switch-port a
 * client is connected to, and its client_id, match. 
 */

void conn(int[4999,5999+clients] &amp;node, port_t &amp;port){


  int[4999,5999+clients] adjacent_n = misconnection;
  phys_ports adjacent_n_p;


            if(node_is_switch(node)) { adjacent_n = first_client + port -1 ;  adjacent_n_p = client_port    ;    } 
            
            
    node = adjacent_n;
    port = adjacent_n_p;
}



int switch_of_client(int[4999,5999+clients] c){
  port_t port_c;       
        conn(c, port_c);
  return c;       
}


int switch_port_of_client(int[4999,5999+clients] c){
  port_t port_c;       
        conn(c, port_c);
  return port_c;       
}


bool valid_switch_port(int[4999,5999+clients] sw, port_t p){
  int[4999,5999+clients] A_node = sw ;
  int[4999,5999+clients] B_node;
        conn(A_node, p);
        B_node = A_node;
  return B_node != misconnection;
}


int number_of_valid_switch_ports(int[4999,5999+clients] sw){
  port_t j;
  int[4999,5999+clients] A_node = sw ;
  int[4999,5999+clients] B_node;
  int p;

    for(i : phys_ports){
        j = i;
        conn(A_node, j);
        B_node = A_node;
        if(B_node != misconnection){
            p++;
        }
    A_node = sw;
    }
  return p;
}



bool switch_client_conn(SW sw, C c){
  int i = 1;
  port_t j;
  bool sw_c;  
  int[4999,5999+clients] A_node;
  int[4999,5999+clients] B_node;
       
    while(i &lt;= ports and not sw_c) {
        j = i;
        A_node = sw;
        conn(A_node, j);
        B_node = A_node;
        if(B_node == c){    
            sw_c = true;
        }
    i++;
    }
  return sw_c;       
}


bool swsw_direct_connection(SW sw1, SW sw2){
  int i = 1;
  port_t j;  
  bool sw_sw;  
  int[4999,5999+clients] A_node ;
  int[4999,5999+clients] B_node;
       
    while(i &lt;= ports and not sw_sw) {
        j = i;
        A_node = sw1;
        conn(A_node, j);
        B_node = A_node;
        if(B_node == sw2){    
            sw_sw = true;
        }
    i++;
    }
  return sw_sw;       
}



int[4999,5999+clients] next_hop_box(port_t out_port, int[4999,5999+clients] A_node ){
    conn(A_node,out_port); 
return A_node;
}


port_t next_hop_box_port(port_t out_port, int[4999,5999+clients] A_node ){
    conn(A_node,out_port); 
return out_port;
}




bool client_connecting_switch_port(SW sw, port_t p){
  int[4999,5999+clients] A_node = sw ;
  int[4999,5999+clients] B_node;

    conn(A_node, p);
    B_node = A_node;
    return node_is_client(B_node);
}


void check_dropped_packet(int32_t pk, SW sw){

  int s    = decode_bitfield(_src_       ,pk);
  int d    = decode_bitfield(_dest_      ,pk);
  int s_p  = decode_bitfield(_src_port_  ,pk);
  int d_p  = decode_bitfield(_dest_port_ ,pk);

    if(flows[s][s_p][d][d_p][sw-first_switch+1]){
        invariant_failed = true;
    }
}




/* We generate here all possible packets according to the 
 * packet fields in question, i.e., src, dest and reached
 */
void generate_Rules(){

  int q[100][switches][2]; // a queue which stores the paths
  int path[switches][2];       // path vector to store the current path as (switch, in_port) tuples
  int newpath[switches];
  bool isNotVisited;
  int stack[switches]; // a stack used to do iterative DFS
  int q_l = 0;
  int path_l = 0;
  int last;
  int vert;
  bool visited[SW];
  int[4999,5999+clients] current_node, next_node;
  int current_in_port, next_in_port;
  int i;
  int path_index; 
  int op = 1;
  int outp = 1;
  int32_t p_32;
  int j = 1;
  int jj = 1;
  int u = first_switch;
  int v ;
  int b;
  int k ; 
  int bits_set;
  int32_t r_32;
  int rru  = 1;
  int ruu = 1;
    undef_rule_32(r_32);
    undef_packet_32(p_32);
    encode_bitfield(_prio_, 1, r_32);
    encode_bitfield(_install_, true, r_32);



    for(s : C){
        for(d : C){
            if(can_communicate(s, d)){
                for(s_p : ip_port_t){
                    for(d_p : ip_port_t){  
                          if(s_p != d_p){            


                                for(op : port_t){
                                    if(  op !=  s - first_client +1  ){ // i.e., don't build rule with fwd_port to the source of the connection

                                                    encode_bitfield(_src_,       s-first_client+1,r_32);
                                                    encode_bitfield(_dest_,      d-first_client+1,r_32);
                                                    encode_bitfield(_src_port_,  s_p,             r_32);
                                                    encode_bitfield(_dest_port_, d_p,             r_32);
                                                    encode_bitfield(_out_port_,  op,              r_32);
                                                        if(op == discard){
                                                            encode_bitfield(_prio_,      1,       r_32);
                                                        }
                                                        else{
                                                            encode_bitfield(_prio_,      2,       r_32);
                                                        }
                                                    R[ruu] = r_32;
                                                    undef_rule_32(r_32);
                                                    r_32 = init_rule;
                                                    ruu++;
                                    }
                                }
                            }                                                
                        }                   
                   }
             }                                                           
        }                        
    }
}



void selectionSort()
{
  int i, j, min_idx, temp;  
    // One by one move boundary of unsorted subarray  
    for (i = 1; i &lt; packets_no; i++)  
    {  
        // Find the minimum element in unsorted array  
        min_idx = i;  
        for (j = i+1; j &lt;= packets_no; j++)  
        if (P[j] &lt; P[min_idx])  
            min_idx = j;  
  
        // Swap the found minimum element with the first element  
        temp = P[min_idx];
        P[min_idx]  = P[i];
        P[i] = temp; 
    }  

    for (i = 1; i &lt; rules_no; i++)  
    {  
        // Find the minimum element in unsorted array  
        min_idx = i;  
        for (j = i+1; j &lt;= rules_no; j++)  
        if (R[j] &lt; R[min_idx])  
            min_idx = j;  
  
        // Swap the found minimum element with the first element  
        temp = R[min_idx];
        R[min_idx]  = R[i];
        R[i] = temp; 
    }  

} 

void BubbleSort()
{
    int i, j;
    int32_t temp;
 	for (i = 1; i &lt;= packets_no; i++)
 	{
		for (j = 1; j &lt;= packets_no - i; j++ )
		{
			if ((P[j] &amp; mask_same_pkt) &gt; (P[j+1]&amp;mask_same_pkt))
            {
                temp = P[j];
                P[j] = P[j+1];
                P[j+1] = temp;
            }
         }
     }


 	for (i = 1; i &lt;= rules_no; i++)
 	{
		for (j = 1; j &lt;= rules_no - i; j++ )
		{
			if ((R[j] &amp; mask_same_rule) &gt; (R[j+1]&amp;mask_same_rule))
            {
                temp = R[j];
                R[j] = R[j+1];
                R[j+1] = temp;
            }
         }
     }

 } 





bool packet_in_pb_32(pkts p, SW sw){
 
    return (  (P[p] &amp; (1 &lt;&lt; (from_bit(_pb_)+sw-first_switch) )) != 0); // it's not like C++ where non zero integers automatically convert to true
}


bool packet_in_pIb_32(pkts p, SW sw){

    return (  (P[p] &amp; (1 &lt;&lt; (from_bit(_pIb_)+sw-first_switch) )) != 0 );
}

bool packet_in_pOb_32(pkts p, SW sw){

    return (  (P[p] &amp; (1 &lt;&lt; (from_bit(_pOb_)+sw-first_switch) )) != 0 );
}





//linear search 
int packet_pos(int32_t pkt)
{
   int j; 

   //loop through array
   for (j = 1; j &lt;= packets_no; ++j)
   {
      if ( oo_32(P[j], pkt))
      {
         return j; 
      }
   }
   return -1; //value not found
}


//binary search
int packet_position(int32_t pkt){

   int first  = 1;
   int last   = packets_no;
   int middle;
   
    while (first &lt;= last)
    {
        middle = first + (last - first)/2;

        if ((pkt&amp;mask_same_pkt) == (P[middle]&amp;mask_same_pkt))
            return middle;

        if ((pkt&amp;mask_same_pkt) &gt; (P[middle]&amp;mask_same_pkt))
            first = middle + 1;
        else 
            last = middle - 1;
    }
    return -1; //search value not found
}





/* This function stores packets to pq of sw. 
 */
void addpkt_32(int32_t pkt, SW sw){  
  int pb_pos = from_bit(_pb_)+sw-first_switch;
    if((pkt &amp; (1 &lt;&lt; (pb_pos) )) == 0){      
        set_bit(  P[packet_pos(pkt)], pb_pos  );
    }
}





void start_all_clients_32(){
  int32_t p_32;
  int j = 1;
  undef_packet_32(p_32);


        for(s: C){
            for(d: C){
                if (can_communicate(s, d)){
                    for(s_p: ip_port_t){
                        for(d_p: ip_port_t){
                            if(s_p != d_p){
                                encode_bitfield(_src_      , s-first_client+1        , p_32);
                                encode_bitfield(_dest_     , d-first_client+1        , p_32);
                                encode_bitfield(_in_port_  , s - first_client +1     , p_32);
                                encode_bitfield(_src_port_ , s_p                     , p_32);
                                encode_bitfield(_dest_port_, d_p                     , p_32);

                                P[j] = p_32;
                                for(sw : SW){
                                    addpkt_32(p_32, sw);
                                }
                                j++;
                            }
                        }
                    }
                }
            }
        }
}




void forward_32(int32_t p, port_t out_port, int[4999,5999+clients] A_node ){

    int[4999,5999+clients] node = A_node;
    C B_node_client;
    SW B_node_switch;
    int32_t new_pk;
    port_t __out_port = out_port;    
    new_pk = p;
    conn(node,__out_port); 

    if(out_port != discard)  {     
        if(node_is_client(node)){ /* node == client */
                B_node_client = node;
              //  client_packet_received_32(new_pk, B_node_client);
        }
        else if(node_is_switch(node)){ /* node is switch */
                           B_node_switch = node; 						   
                           encode_bitfield(_in_port_, __out_port, new_pk);
                           addpkt_32(new_pk,B_node_switch);
         }
        else if(node == misconnection) {  /* Packet loss due to misconnection (the conn-function didn't find entry)  */
        }
    }
}





void flood_32(int32_t p, SW sw){
    for(i : phys_ports){
        if(i != decode_bitfield(_in_port_,p)  and valid_switch_port(sw, i)  ){  /* All valid physical ports except input port and the symbolic 'discard' one. */
           forward_32(p, i, sw);
        }
    }
}





/* A packet matches a flow table entry if the values in the packet match fields used for the lookup match
 * those defined in the flow table entry. If a flow table entry field has a value of ANY (field omitted), it
 * matches all possible values in the header.
 */
bool matched_32(int32_t p, int32_t r)
{
  int32_t r_src_m =  r &amp; mask_src;
  int32_t p_src_m =  p &amp; mask_src;

  int32_t r_dest_m =  r &amp; mask_dest;
  int32_t p_dest_m =  p &amp; mask_dest;

  int32_t r_src_port_m =  r &amp; mask_src_port;
  int32_t p_src_port_m =  p &amp; mask_src_port;

  int32_t r_dest_port_m =  r &amp; mask_dest_port;
  int32_t p_dest_port_m =  p &amp; mask_dest_port;

	return( r != 0

          and  (  r_src_m     == wildcard or r_src_m     == p_src_m       )  
          and  (  r_dest_m    == wildcard or r_dest_m    == p_dest_m      )  
          and  (  r_src_port_m == wildcard or r_src_port_m == p_src_port_m   )  
          and  (  r_dest_port_m == wildcard or r_dest_port_m == p_dest_port_m   )  
    ) ;
}






bool there_is_a_match_in_ft_32(int32_t p, SW sw)
{
	return(  exists(i : rul)  
              matched_32(p, R[i]) &amp;&amp;
              rule_installed_32(i,sw) 
    ) ;
}







//============





/* returns the highest priority whose rule matches the packet to be forwarded
 *** The packet is matched against the table and only the highest priority flow entry that matches the
 *** packet must be selected. 
 */
priority_t highest_priority_match_32(int32_t p, SW sw){
  priority_t max = 0;
  priority_t current_priority;

    for(i : rul){
      if(rule_installed_32(i,sw) and matched_32(p, R[i])){
        current_priority = priority_of_rule_32(R[i]);
            if(max &lt; current_priority){
                max = current_priority;
            }
      }
    }
return max;
}




/* returns the the highest priority rule index whose pattern matches the packet in switch sw’s flow table. */ 
int rule_index_best_match_32(int32_t p, SW sw){
  priority_t current_priority;
  int j;

        current_priority = highest_priority_match_32(p, sw);

        if (current_priority &gt; 0){  /* there's a match */
            for(j : rul){
                if(rule_installed_32(j,sw) and priority_of_rule_32(R[j]) == current_priority and matched_32(p,R[j])) {
                    return j;
				}
			}
		}
	return -1;  //value not found
}



bool fwd_is_visible_32(int32_t p, port_t out_port, int[4999,5999+clients] A_node ) {

    return true ; // visible because an otome is changed
}



/*
 * ctrl gets visible if the p.src changes: "p:MAC == pseudo:MAC" is the only atom that could make ctrl visible
 */
bool ctrl_is_visible_32(int32_t p, SW sw ) {
    return false; 
}




bool should_allow(int32_t p){

  C1        p_src        = decode_bitfield(_src_      , p); 
  C1        p_dest       = decode_bitfield(_dest_     , p);
  ip_port_t p_src_port   = decode_bitfield(_src_port_ , p);
  ip_port_t p_dest_port  = decode_bitfield(_dest_port_, p);

	return(   
            (
		        (p_src  +first_client -1  == 6000 )    and 
	            (p_src_port               == 1    )    and 
	            (p_dest +first_client -1  == 6003 )    and
	            (p_dest_port              == 2    )
            )
    ) ;
}

//int32_t test;


/* Here we set the function barrier-ids to set of rules
 *
 */
void add_rule_to_gV_32(SW sw){
  int i = 0; 
  SW1 sw1 =  sw - first_switch +1;
  //  if(bRb[sw][1] == true) // bRb is an FIFO queue
  //  {
        flows[1][1][4][2][sw1] = true;
        flows[4][2][1][1][sw1] = true;
   // }
    bRb[sw][1] =  false;
}

/*
 * ========================================================================================
 *                                                                     
 *   CONTROLLER PROGRAM
 *
 * ========================================================================================
 */

void controller_32(pkts p, SW sw){

  int barrier_id, r2;

  int32_t pkt = P[p];
  int32_t p_m;
  int32_t rule1, rule2, drop_rule;
  C1 pkt_src, pkt_dest;
  ip_port_t pkt_src_port, pkt_dest_port;
  int32_t mask = mask_src | mask_dest |  mask_src_port  |  mask_dest_port ;
  p_m = pkt &amp; mask;

        pkt_src       = decode_bitfield(_src_      ,pkt);//+first_client -1; 
        pkt_dest      = decode_bitfield(_dest_     ,pkt);//+first_client -1;
        pkt_src_port  = decode_bitfield(_src_port_ ,pkt); 
        pkt_dest_port = decode_bitfield(_dest_port_,pkt);

    if(pkt_src == 1 and pkt_src_port  ==1 and pkt_dest == 4 and pkt_dest_port  == 2){barrier_id = 1;}

    if(should_allow(pkt)){ // i.e., if inspected packet p matches an existing firewall allow-rule in configure_table


        rule1 = init_rule;
            // we copy the src-dest-src_port-src_dest from pkt to rule1
            rule1 &amp;= (mask ^ -1);
            rule1 |= p_m;
            encode_bitfield(_prio_,2,  rule1);
            encode_bitfield(_out_port_,   pkt_dest,  rule1); /* according to the topology at stake, 
                                                              * the host with id=x is connected to 
                                                              * port x of the switch                 */


        rule2 = init_rule;
            encode_bitfield(_src_,       pkt_dest,      rule2);
            encode_bitfield(_src_port_,  pkt_dest_port, rule2);
            encode_bitfield(_dest_,      pkt_src,       rule2);
            encode_bitfield(_dest_port_, pkt_src_port,  rule2);

            encode_bitfield(_prio_,2,  rule2);
            encode_bitfield(_out_port_,   pkt_src,  rule2);

                r2 = rule_position_32(rule2);
                encode_barrier_for_specific_switch(barrier_id, R[r2], sw);               
            for(s:SW){ // send everywhere because the switches are replicated so all are provisioned
                send_rule_32(rule_position_32(rule1), s); 
                send_rule_32(r2, s);
            }
        if(fwd_optimisation == 1){ /* fwd is always invisible for the given property 
                                    * (because the property talks about dropped packets)
                                    */
            forward_32(pkt,  pkt_dest, sw); /* according to the topology, the switch-port 
                                             * a client is connected to, and its client_id, match.  
                                             */  
        }
        else{
                set_bit(P[p], from_bit(_pOb_)+sw-first_switch );
                encode_bitfield(_out_port_, pkt_dest, P[p]);
        }
    }
    else{

        drop_rule = init_rule;
            drop_rule &amp;= (mask ^ -1);
            drop_rule |= p_m;

            encode_bitfield(_prio_,1,            drop_rule);
            encode_bitfield(_out_port_, discard, drop_rule);

        for(s:SW){
            send_rule_32(rule_position_32(drop_rule), s);
        }

        if(fwd_optimisation != 1){ 
        /* a fwd()-action with drop-ports is always invisible: because our property 
         * talks only about dropped by the rules in switches
         *
         */
        
           set_bit(P[p], from_bit(_pOb_)+sw-first_switch );
           encode_bitfield(_out_port_, discard, P[p]);   
        }    
    }
}</declaration>
	<template>
		<name>undef</name>
		<declaration>void undefine_queues(){
    int i;
       for(i : pkts){
            undef_packet_32(P[i]);
       }
       for(i : rul){
           undef_rule_32(R[i]);
       }    
}




void off(){
        undefine_queues();
  //      generate_configure_rules();
        generate_Rules();
//selectionSort();
//        BubbleSort();
        start_all_clients_32();  
  
//encode_barrier_for_specific_switch(1, R[1], 5000);                                     
}
</declaration>
		<location id="id0" x="119" y="59">
		</location>
		<location id="id1" x="42" y="85">
			<committed/>
		</location>
		<init ref="id1"/>
		<transition>
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="assignment" x="17" y="195">off()</label>
			<nail x="42" y="153"/>
			<nail x="132" y="89"/>
		</transition>
	</template>
	<template>
		<name>pqSw</name>
		<parameter>const SW sw</parameter>
		<declaration>
void remove_pk_from_pq_32(pkts p, SW sw){
    if(oo_pq != 1 ){
                    clear_bit(P[p], from_bit(_pb_)+sw-first_switch );        
    }
}




void process_unmatched_packets_32(pkts p, SW sw){
        if(ctrl_optimisation == 1 and not ctrl_is_visible_32(P[p], sw) ){
            controller_32(p, sw);
        }
        else{
            set_bit(  P[p], from_bit(_pIb_)+sw-first_switch  );
         }
        remove_pk_from_pq_32(p, sw);
}




void forward_matched_pkt_32(pkts p, SW A_node ){
    int32_t new_p;
    int[4999,5999+clients] node = A_node;
    C B_node_client;
    SW B_node_switch;
    port_t out_port, __out_port;
    new_p = P[p];
    out_port = out_port_of_rule_32(R[rule_index_best_match_32(new_p, A_node)]);
    __out_port = out_port;

    if(out_port != discard){
        conn(node, __out_port ); 
        if(node_is_client(node)){ /* node == client */
                B_node_client = node;
            //    client_packet_received(new_p, B_node_client);

        }
        else if(node_is_switch(node)){ /* node is switch */
                           B_node_switch = node;
                           encode_bitfield(_in_port_, __out_port, new_p);
                           addpkt_32(new_p,B_node_switch);
        }
        else if(node == misconnection) {  /* Packet loss due to misconnection (the conn-function didn't find entry)  */

        }
    }
    else{
        check_dropped_packet(P[p], A_node);

    }
    remove_pk_from_pq_32(p, A_node );
}


void proces_matched_pkts_32(pkts p, SW sw)
{
    forward_matched_pkt_32(p, sw);
    if(all_pkts_1_shot == 1){
        for(i : pkts)
            if(packet_in_pb_32(i, sw) and rule_index_best_match_32(P[p], sw) == rule_index_best_match_32(P[i], sw) and p != i){
                forward_matched_pkt_32(i, sw);
            }
        }
}</declaration>
		<location id="id2" x="0" y="0">
		</location>
		<init ref="id2"/>
		<transition>
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="select" x="-161" y="51">p : pkts</label>
			<label kind="guard" x="-246" y="85">packet_in_pb_32(p, sw) &amp;&amp;
!there_is_a_match_in_ft_32(P[p], sw)</label>
			<label kind="assignment" x="-238" y="127">process_unmatched_packets_32(p, sw)</label>
			<label kind="comments" x="34" y="68">TABLE-MISS</label>
			<nail x="-25" y="68"/>
			<nail x="17" y="102"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="select" x="-221" y="-221">p : pkts</label>
			<label kind="guard" x="-289" y="-170">packet_in_pb_32(p, sw) &amp;&amp;
there_is_a_match_in_ft_32(P[p], sw)</label>
			<label kind="assignment" x="-229" y="-93">proces_matched_pkts_32(p, sw )</label>
			<label kind="comments" x="51" y="-68">MATCH</label>
			<nail x="0" y="-68"/>
			<nail x="42" y="-68"/>
		</transition>
	</template>
	<template>
		<name>pIq</name>
		<declaration>






void remove_pk_from_pIq_32(pkts p, SW sw){   
int i,j;
        if(oo_pIOq != 1  
                     //   or (oo_pIOq == 1 and !oo_alpha(Packets[p], sw) )
                                                                        ){    	
 	        clear_bit(P[p], from_bit(_pIb_)+sw-first_switch ); 
        }	
}
</declaration>
		<location id="id3" x="-51" y="-68">
		</location>
		<init ref="id3"/>
		<transition>
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="select" x="-365" y="-255">p : pkts,
sw: SW</label>
			<label kind="guard" x="-374" y="-187">packet_in_pIb_32(p, sw)</label>
			<label kind="assignment" x="-391" y="-127">controller_32(p,  sw),
remove_pk_from_pIq_32(p, sw)</label>
			<nail x="-281" y="-34"/>
			<nail x="-281" y="-68"/>
		</transition>
	</template>
	<template>
		<name>pOq</name>
		<parameter>const SW sw</parameter>
		<declaration>

void remove_pk_from_pOq_32(pkts p, SW sw){
    if(oo_pIOq != 1){
        clear_bit(P[p], from_bit(_pOb_)+sw-first_switch );
    }
}</declaration>
		<location id="id4" x="0" y="0">
		</location>
		<init ref="id4"/>
		<transition>
			<source ref="id4"/>
			<target ref="id4"/>
			<label kind="select" x="-153" y="-153">p : pkts</label>
			<label kind="guard" x="-144" y="-127">packet_in_pOb_32(p, sw)</label>
			<label kind="assignment" x="-170" y="-59">forward_32(P[p], out_port_of_packet_32(P[p]), sw),
remove_pk_from_pOq_32(p, sw)</label>
			<nail x="-162" y="0"/>
			<nail x="-162" y="85"/>
		</transition>
	</template>
	<template>
		<name>cq</name>
		<parameter>const SW sw</parameter>
		<declaration>/* It is never the case that a barriered rule suceeds an unbarriered one
 *
 * dependencies means that:
 * 1) if the rule is non-barriered then there is a barrier out for that switch: 
 * 2) else (the rule is barriered) all previous are barriered, so, do the below
 */
bool dependencies_precede(SW sw, rul r){
int b_r = decode_barrier_for_specific_switch(R[r],sw);

	return(  exists(i : rul)  exists(j : bar)

            (        b_r == 0
              and    barriers_out[sw][j] != 0                                                  
            )
            or
            (
             b_r != 0                                  
             and rule_in_cb_32(i, sw) 
             and decode_barrier_for_specific_switch(R[i], sw) != 0
             and b1_earlier_than_b2(decode_barrier_for_specific_switch(R[i], sw),   b_r,  sw)   
            )                                                                                              
        ) ;
}

void remove_rule_from_cq_32(rul r, SW sw){
    if(oo_cq != 1){

        //unset_bitfield(_cb_, R[r]);

        clear_bit(R[r], from_bit(_cb_)+sw-first_switch );
    }
}


</declaration>
		<location id="id5" x="63" y="90">
			<label kind="comments" x="-263" y="51">Α switch is allowed to arbitrarily reorder
processing of control-plane messages;
Here we process them nondeterministically.</label>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id5"/>
			<target ref="id5"/>
			<label kind="select" x="102" y="153">r : rul</label>
			<label kind="guard" x="93" y="170">!dependencies_precede(sw, r) &amp;&amp;
rule_in_cb_32(r, sw)  &amp;&amp;
rule_adds_flow_entry_32(r, sw) and
!rule_installed_32(r, sw)</label>
			<label kind="assignment" x="93" y="246">remove_rule_from_cq_32(r, sw),
add_rule_to_ft_32(r, sw)</label>
			<label kind="comments" x="178" y="127">INSTALL RULE</label>
			<nail x="170" y="144"/>
			<nail x="114" y="141"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id5"/>
			<label kind="select" x="51" y="-161">r : rul</label>
			<label kind="guard" x="34" y="-93">!dependencies_precede(sw, r) &amp;&amp;
rule_in_cb_32(r, sw)  &amp;&amp;
!rule_adds_flow_entry_32(r, sw) and
rule_installed_32(r, sw)</label>
			<label kind="assignment" x="85" y="-17">remove_rule_from_ft_32(r, sw),
remove_rule_from_cq_32(r, sw)</label>
			<label kind="comments" x="178" y="34">UNINSTALL RULE</label>
			<nail x="170" y="34"/>
			<nail x="119" y="34"/>
		</transition>
	</template>
	<template>
		<name>gV</name>
		<declaration>bool bRb_not_empty(SW sw)
{
    return( exists (i : bar) 
           bRb[sw][1] == true   // consider bRb is an FIFO queue
      );    
}</declaration>
		<location id="id6" x="0" y="0">
		</location>
		<init ref="id6"/>
		<transition>
			<source ref="id6"/>
			<target ref="id6"/>
			<label kind="select" x="8" y="-85">sw: SW</label>
			<label kind="guard" x="17" y="-51">bRb_not_empty(sw)</label>
			<label kind="assignment" x="34" y="-25">add_rule_to_gV_32(sw)</label>
			<label kind="comments" x="0" y="76">This process simulates the barrier_reply.</label>
			<nail x="102" y="0"/>
			<nail x="102" y="51"/>
		</transition>
	</template>
	<system>system undef, pqSw, pIq, pOq, cq, gV;

//system test;</system>
	<queries>
		<query>
			<formula>A[] forall (s: SW) forall (p: pkts) !(packet_has_visited_switch(p,s) and packet_in_pb_32(p,s) )
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] forall (s: SW) forall (p: pkts) not (Packets[p].reached[s] and Packets[p].pq[s] )
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>E&lt;&gt; p_cntr  == 16
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] forall (s: SW) forall (p: pkts)   (packet_in_pOb_32(p,s) and p == pseudo_id) imply (packet_MAC(P[p])== pseudo_MAC and delta_MAC == pseudo_MAC)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; p_cntr  &gt;= 15)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] not invariant_failed
			</formula>
			<comment>
			</comment>
		</query>
	</queries>
</nta>
